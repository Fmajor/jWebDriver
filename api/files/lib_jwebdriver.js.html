<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib\jwebdriver.js - jwebdriver</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="https://raw.github.com/yaniswang/jWebDriver/master/logo_s.png" title="jwebdriver"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Browser.html">Browser</a></li>
                                <li><a href="../classes/Elements.html">Elements</a></li>
                                <li><a href="../classes/JWebDriver.html">JWebDriver</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: lib\jwebdriver.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;
/**
 * A webdriver client for Node.js
 * &lt;p&gt;
 * You can use JWebDriver connect to local webdriver or webdriver grid.
 * &lt;/p&gt;
 * @class JWebDriver
 */

const extend = require(&#x27;xtend&#x27;);
const request = require(&#x27;request&#x27;);
const PromiseClass = require(&#x27;promiseclass&#x27;);

const mapCommands = require(&#x27;./commands.js&#x27;);
const Browser = require(&#x27;./browser&#x27;);
const Elements = require(&#x27;./elements&#x27;);

// color list
const colors = {
    black: &#x27;\x1b[0;30m&#x27;,
    dkgray: &#x27;\x1b[1;30m&#x27;,
    brick: &#x27;\x1b[0;31m&#x27;,
    red: &#x27;\x1b[1;31m&#x27;,
    green: &#x27;\x1b[0;32m&#x27;,
    lime: &#x27;\x1b[1;32m&#x27;,
    brown: &#x27;\x1b[0;33m&#x27;,
    yellow: &#x27;\x1b[1;33m&#x27;,
    navy: &#x27;\x1b[0;34m&#x27;,
    blue: &#x27;\x1b[1;34m&#x27;,
    violet: &#x27;\x1b[0;35m&#x27;,
    magenta: &#x27;\x1b[1;35m&#x27;,
    teal: &#x27;\x1b[0;36m&#x27;,
    cyan: &#x27;\x1b[1;36m&#x27;,
    ltgray: &#x27;\x1b[0;37m&#x27;,
    white: &#x27;\x1b[1;37m&#x27;,
    reset: &#x27;\x1b[0m&#x27;
};

// webdriver response codes
const mapResponseCodes = {
    &#x27;-1&#x27;: {type: &#x27;RequestError&#x27;, message:   &#x27;Error on request.&#x27;},
    &#x27;0&#x27;: {type: &#x27;Success&#x27;, message: &#x27;The command executed successfully.&#x27;},
    &#x27;7&#x27;: {type: &#x27;NoSuchElement&#x27;, message: &#x27;An element could not be located on the page using the given search parameters.&#x27;},
    &#x27;8&#x27;: {type: &#x27;NoSuchFrame&#x27;, message: &#x27;A request to switch to a frame could not be satisfied because the frame could not be found.&#x27;},
    &#x27;9&#x27;: {type: &#x27;UnknownCommand&#x27;, message: &#x27;The requested resource could not be found, or a request was received using an HTTP method that is not supported by the mapped resource.&#x27;},
    &#x27;10&#x27;: {type: &#x27;StaleElementReference&#x27;, message: &#x27;An element command failed because the referenced element is no longer attached to the DOM.&#x27;},
    &#x27;11&#x27;: {type: &#x27;ElementNotVisible&#x27;, message: &#x27;An element command could not be completed because the element is not visible on the page.&#x27;},
    &#x27;12&#x27;: {type: &#x27;InvalidElementState&#x27;, message: &#x27;An element command could not be completed because the element is in an invalid state (e.g. attempting to click a disabled element).&#x27;},
    &#x27;13&#x27;: {type: &#x27;UnknownError&#x27;, message: &#x27;An unknown server-side error occurred while processing the command.&#x27;},
    &#x27;15&#x27;: {type: &#x27;ElementIsNotSelectable&#x27;, message: &#x27;An attempt was made to select an element that cannot be selected.&#x27;},
    &#x27;17&#x27;: {type: &#x27;JavaScriptError&#x27;, message: &#x27;An error occurred while executing user supplied JavaScript.&#x27;},
    &#x27;19&#x27;: {type: &#x27;XPathLookupError&#x27;, message: &#x27;An error occurred while searching for an element by XPath.&#x27;},
    &#x27;23&#x27;: {type: &#x27;NoSuchWindow&#x27;, message: &#x27;A request to switch to a different window could not be satisfied because the window could not be found.&#x27;},
    &#x27;24&#x27;: {type: &#x27;InvalidCookieDomain&#x27;, message: &#x27;An illegal attempt was made to set a cookie under a different domain than the current page.&#x27;},
    &#x27;25&#x27;: {type: &#x27;UnableToSetCookie&#x27;, message: &#x27;A request to set a cookie\&#x27;s value could not be satisfied.&#x27;},
    &#x27;26&#x27;: {type: &#x27;UnexpectedAlertOpen&#x27;, message: &#x27;A modal dia&#x60; was open, blocking this operation&#x27;},
    &#x27;27&#x27;: {type: &#x27;NoAlertOpenError&#x27;, message: &#x27;An attempt was made to operate on a modal dialog when one was not open.&#x27;},
    &#x27;28&#x27;: {type: &#x27;ScriptTimeout&#x27;, message: &#x27;A script did not complete before its timeout expired.&#x27;},
    &#x27;29&#x27;: {type: &#x27;InvalidElementCoordinates&#x27;, message: &#x27;The coordinates provided to an interactions operation are invalid.&#x27;},
    &#x27;30&#x27;: {type: &#x27;IMENotAvailable&#x27;, message: &#x27;IME was not available.&#x27;},
    &#x27;31&#x27;: {type : &#x27;IMEEngineActivationFailed&#x27;, message: &#x27;An IME engine could not be started.&#x27;},
    &#x27;32&#x27;: {type: &#x27;InvalidSelector&#x27;, message: &#x27;Argument was an invalid selector (e.g. XPath/CSS).&#x27;}
};

// default config
const defConfig = {
	&#x27;host&#x27;: &#x27;127.0.0.1&#x27;,
	&#x27;port&#x27;: 4444,
    &#x27;logLevel&#x27;: 0, // 0: no log, 1: warning &amp; error, 2: all log
    &#x27;nocolor&#x27;: false,
    &#x27;speed&#x27;: 0
};

const JWebDriver = PromiseClass.create({

    /**
     * init driver
     * @method constructor
     * @private
     * @param  {String|Object} [host] webdriver server ip or options
     * @param  {String} [port] webdriver server port
     */
    constructor(host, port) {
        let self = this;
        let options;
        if(port !== undefined){
            options = {
                host: host,
                port: port
            };
        }
        else{
            options = host;
        }
        let config = extend({}, defConfig, options);
        self.config = config;
    },

    /**
     * get webdriver server info
     * @method info
     * @public
     * @param  {Function} done callback function
     */
    info(done){
        this.execStrict(&#x27;getStatus&#x27;, function(error, ret){
            done(error, ret &amp;&amp; ret.value);
        });
    },

    /**
     * save log
     * @method log
     * @public
     * @param  {COMMAND|DATA|RESULT|ERROR|WARNING|INFO} type log type
     * @param  {Object} message log message
     */
    log(type, message){
        let self = this;
        let config = self.config;
        let logLevel = config.logLevel;
        let nocolor = config.nocolor;
        if(logLevel === 2 || (logLevel === 1 &amp;&amp; (type === &#x27;ERROR&#x27; || type === &#x27;WARNING&#x27;))){
            let dateString = (new Date()).toString().match(/\d\d:\d\d:\d\d/)[0];
            let mapColors = {
                &#x27;COMMAND&#x27;: colors.violet,
                &#x27;DATA&#x27;: colors.brown,
                &#x27;RESPONSE&#x27;: colors.teal,
                &#x27;ERROR&#x27;: colors.red,
                &#x27;WARNING&#x27;: colors.yellow,
                &#x27;INFO&#x27;: colors.white
            };
            if(nocolor === true){
                console.log(&#x27;[&#x27; + dateString + &#x27;]: &#x27;, type, &#x27;\t&#x27;, message);
            }
            else{
                console.log(colors.dkgray +&#x27;[&#x27; + dateString + &#x27;]: &#x27; + colors.reset, mapColors[type] + type + colors.reset, &#x27;\t&#x27;, message);
            }
        }
    },

    /**
     * sleep sync
     * @method sleep
     * @public
     * @param  {Number} ms
     * @param  {Function} done callback function
     */
    sleep(ms, done){
        this.log(&#x27;COMMAND&#x27;, &#x27;SLEEP\t&#x27;+ms);
        setTimeout(done, ms);
    },

    /**
     * request sync
     * @method requestSync
     * @public
     * @param  {object} options
     * @param  {Function} done callback function
     * @return {Object} error, {response:{}, body:{}}
     */
    request(options, done){
        request(options, function(error, response, body){
            done(error, {
                response: response,
                body: body
            });
        });
    },

    /**
     * execute protocal command
     * @method exec
     * @public
     * @param  {String} cmd protocal command, defined in command.js
     * @param  {Object} [pathData] replace the path parameters
     * @param  {Object} [data] send data to protocal api
     * @param  {Function} done callback function
     * @return {Object} the return object from webdriver server
     */
    exec(cmd, pathData, data, done){
        let self = this;
        let config = self.config;
        let cmdInfo = mapCommands[cmd];
        if(typeof pathData === &#x27;function&#x27;){
            pathData = undefined;
            data = undefined;
        }
        else if(typeof data === &#x27;function&#x27;){
            data = undefined;
        }
        done = getDone(arguments);
        if(cmdInfo !== undefined){
            let host = config.host;
            let port = config.port;
            let method = cmdInfo[0];
            let apiPath = cmdInfo[1];
            pathData = pathData || {};
            for(let name in pathData){
                apiPath = apiPath.replace(&#x27;:&#x27;+name, encodeURIComponent(pathData[name]));
            }
            self.log(&#x27;COMMAND&#x27;, method + &#x27;\t&#x27; + apiPath);
            if(data){
                data = JSON.stringify(data);
                // encode Unicode
                data = data.replace(/[^\x00-\xff]/g, function(a){
                    return &#x27;\\&#x27;+escape(a).substr(1);
                });
                if(data !== &#x27;{}&#x27;){
                    self.log(&#x27;DATA&#x27;, data);
                }
            }
            else{
                data = &#x27;&#x27;;
            }
            let url = &#x27;http://&#x27;+host+&#x27;:&#x27;+port+&#x27;/wd/hub&#x27;+apiPath;
            let headers = {
                &#x27;Accept&#x27;: &#x27;application/json; charset=utf-8&#x27;,
                &#x27;Content-Type&#x27;: &#x27;application/json;charset=UTF-8&#x27;,
                &#x27;Content-Length&#x27;: data.length
            };
            self.request({
                method: method,
                url: url,
                headers: headers,
                body: data,
                timeout: 600000
            }, function(error, response){
                if(error){
                    done(error);
                }
                else{
                    let body = response.body;
                    response = response.response;
                    try{
                        body = JSON.parse(body);
                    }
                    catch(e){
                        return done(&#x27;JSON parse failed: &#x27;+e);
                    }
                    if(response.statusCode === 200){
                        let wdStatus = body.status;
                        if(wdStatus === 0){
                            let value = body.value;
                            if(value &amp;&amp; value.hCode !== undefined){
                                delete value[&#x27;hCode&#x27;];
                                delete value[&#x27;class&#x27;];
                            }
                            self.log(&#x27;RESPONSE&#x27;, value);
                        }
                        else{
                            let responseErrorInfo = mapResponseCodes[wdStatus];
                            body.errorType = responseErrorInfo.type;
                            body.errorMessage = responseErrorInfo.message;
                            self.log(&#x27;WARNING&#x27;, responseErrorInfo.type);
                        }
                    }
                    else{
                        let errorInfo = body.value;
                        let newErrorInfo = {
                            additionalInformation: errorInfo.additionalInformation,
                            systemInformation: errorInfo.systemInformation,
                            message: errorInfo.message
                        };
                        self.log(&#x27;ERROR&#x27;, newErrorInfo);
                        return done(&#x27;The status of cmd response is: &#x27;+response.statusCode);
                    }
                    if(config.speed &gt; 0){
                        self.sleep(config.speed, function(){
                            done(null, body);
                        });
                    }
                    else{
                        done(null, body);
                    }
                }
            });
        }
        else{
            done(&#x27;Invalid cmd&#x27;);
        }
    },

    /**
     * execute protocal command strictly
     * @method execStrict
     * @public
     * @param  {String} cmd protocal command, defined in command.js
     * @param  {Object} [pathData] replace the path parameters
     * @param  {Object} [data] send data to protocal api
     * @param  {Function} done callback function
     * @return {Object} the return object from webdriver server
     */
    execStrict(cmd, pathData, data, done){
        let self = this;
        if(typeof pathData === &#x27;function&#x27;){
            pathData = undefined;
            data = undefined;
        }
        else if(typeof data === &#x27;function&#x27;){
            data = undefined;
        }
        done = getDone(arguments);
        self.exec(cmd, pathData, data, function(error, ret){
            if(error){
                done(error);
            }
            else{
                let errorType = ret.errorType;
                if(errorType){
                    done(errorType);
                }
                else{
                    done(null, ret);
                }
            }
        });
    },

    /**
     * get all sessions
     * @method sessions
     * @public
     * @param  {Function} done callback function
     * @return {Array} sessions array
     */
    sessions(done){
        let self = this;
        self.execStrict(&#x27;getSessions&#x27;, function(error, ret){
            if(error){
                done(error);
            }
            else{
                let arrSessionsInfos = ret.value;
                let arrSessions = [];
                let arrPromise = [];
                function getSession(sessionInfo){
                   arrPromise.push(new Promise(function(resolve){
                        self.session({
                            sessionId: sessionInfo.id
                        }, function(error, ret){
                            arrSessions.push(ret);
                            resolve();
                        });
                    }));
                }
                for(let i=0,len=arrSessionsInfos.length;i&lt;len;i++){
                    getSession(arrSessionsInfos[i]);
                }
                Promise.all(arrPromise).then(function(){
                    done(null, arrSessions);
                }).catch(done);
            }
        });
    },

    /**
     * init new session or attach to a session id
     * @method session
     * @public
     * @param  {String|Object} browserName or capabilitie object
     * @param  {String} version
     * @param  {String} platform
     * @param  {Function} done callback function
     * @return {Browser} Browser object
     */
    session(browserName, version, platform, done){
        if(typeof version === &#x27;function&#x27;){
            version = undefined;
            platform = undefined;
        }
        else if(typeof platform === &#x27;function&#x27;){
            platform = undefined;
        }
        done = getDone(arguments);
        var browser = new Browser(this, browserName, version, platform);
        browser.init(function(error){
            done(error, browser);
        }).catch(done);
    }

});

// get done callback
function getDone(args){
    let done = args[args.length -1];
    return typeof done === &#x27;function&#x27; ? done : null;
}

// expose Browser &amp; Elements
JWebDriver.Browser = Browser;
JWebDriver.Elements = Elements;

module.exports = JWebDriver;

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
