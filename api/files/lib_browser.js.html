<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/browser.js - jwebdriver</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="https://raw.github.com/yaniswang/jWebDriver/master/logo_s.png" title="jwebdriver"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.1.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Browser.html">Browser</a></li>
                                <li><a href="../classes/Elements.html">Elements</a></li>
                                <li><a href="../classes/JWebDriver.html">JWebDriver</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: lib/browser.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x27;use strict&#x27;;
/**
 * This class is used for control browser.
 * @class Browser
 */

const fs = require(&#x27;fs&#x27;);
const os = require(&#x27;os&#x27;);
const path = require(&#x27;path&#x27;);

const PromiseClass = require(&#x27;promiseclass&#x27;);
const extend = require(&#x27;xtend&#x27;);
const Zip = require(&#x27;node-zip&#x27;);
const HostsProxy = require(&#x27;./hostsproxy&#x27;);

const Elements = require(&#x27;./elements&#x27;);

// default options for browser
const defaultBrowserOptions = {
    &#x27;browserName&#x27;: &#x27;chrome&#x27;,
    &#x27;version&#x27;: &#x27;ANY&#x27;,
    &#x27;platform&#x27;: &#x27;ANY&#x27;
};

// nick name for browser
const mapBrowserNickName = {
    &#x27;ie&#x27;: &#x27;internet explorer&#x27;,
    &#x27;ff&#x27;: &#x27;firefox&#x27;,
    &#x27;edge&#x27;: &#x27;MicrosoftEdge&#x27;
};

// https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/click
const MouseButtons = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
};

// https://code.google.com/p/selenium/wiki/JsonWireProtocol#/session/:sessionId/element/:id/value
const Keys = {
    NULL: &#x27;\uE000&#x27;,
    CANCEL: &#x27;\uE001&#x27;,
    HELP: &#x27;\uE002&#x27;,
    BACK_SPACE: &#x27;\uE003&#x27;,
    TAB: &#x27;\uE004&#x27;,
    CLEAR: &#x27;\uE005&#x27;,
    RETURN: &#x27;\uE006&#x27;,
    ENTER: &#x27;\uE007&#x27;,
    SHIFT: &#x27;\uE008&#x27;,
    CONTROL: &#x27;\uE009&#x27;,
    CTRL: &#x27;\uE009&#x27;,
    ALT: &#x27;\uE00A&#x27;,
    PAUSE: &#x27;\uE00B&#x27;,
    ESCAPE: &#x27;\uE00C&#x27;,
    SPACE: &#x27;\uE00D&#x27;,
    PAGE_UP: &#x27;\uE00E&#x27;,
    PAGE_DOWN: &#x27;\uE00F&#x27;,
    END: &#x27;\uE010&#x27;,
    HOME: &#x27;\uE011&#x27;,
    ARROW_LEFT: &#x27;\uE012&#x27;,
    LEFT: &#x27;\uE012&#x27;,
    ARROW_UP: &#x27;\uE013&#x27;,
    UP: &#x27;\uE013&#x27;,
    ARROW_RIGHT: &#x27;\uE014&#x27;,
    RIGHT: &#x27;\uE014&#x27;,
    ARROW_DOWN: &#x27;\uE015&#x27;,
    DOWN: &#x27;\uE015&#x27;,
    INSERT: &#x27;\uE016&#x27;,
    DELETE: &#x27;\uE017&#x27;,
    SEMICOLON: &#x27;\uE018&#x27;,
    EQUALS: &#x27;\uE019&#x27;,

    NUMPAD0: &#x27;\uE01A&#x27;,
    NUMPAD1: &#x27;\uE01B&#x27;,
    NUMPAD2: &#x27;\uE01C&#x27;,
    NUMPAD3: &#x27;\uE01D&#x27;,
    NUMPAD4: &#x27;\uE01E&#x27;,
    NUMPAD5: &#x27;\uE01F&#x27;,
    NUMPAD6: &#x27;\uE020&#x27;,
    NUMPAD7: &#x27;\uE021&#x27;,
    NUMPAD8: &#x27;\uE022&#x27;,
    NUMPAD9: &#x27;\uE023&#x27;,
    MULTIPLY: &#x27;\uE024&#x27;,
    ADD: &#x27;\uE025&#x27;,
    SEPARATOR: &#x27;\uE026&#x27;,
    SUBTRACT: &#x27;\uE027&#x27;,
    DECIMAL: &#x27;\uE028&#x27;,
    DIVIDE: &#x27;\uE029&#x27;,

    F1: &#x27;\uE031&#x27;,
    F2: &#x27;\uE032&#x27;,
    F3: &#x27;\uE033&#x27;,
    F4: &#x27;\uE034&#x27;,
    F5: &#x27;\uE035&#x27;,
    F6: &#x27;\uE036&#x27;,
    F7: &#x27;\uE037&#x27;,
    F8: &#x27;\uE038&#x27;,
    F9: &#x27;\uE039&#x27;,
    F10: &#x27;\uE03A&#x27;,
    F11: &#x27;\uE03B&#x27;,
    F12: &#x27;\uE03C&#x27;,

    COMMAND: &#x27;\uE03D&#x27;,
    META: &#x27;\uE03D&#x27;
};

const mapCapabilities = {
    javascript: &#x27;javascriptEnabled&#x27;,
    cssselector: &#x27;cssSelectorsEnabled&#x27;,
    screenshot: &#x27;takesScreenshot&#x27;,
    storage: &#x27;webStorageEnabled&#x27;,
    alert: &#x27;handlesAlerts&#x27;,
    database: &#x27;databaseEnabled&#x27;,
    rotatable : &#x27;rotatable&#x27;
};

const Browser = PromiseClass.create({

    /**
     * mouse buttons
     * @property MouseButtons
     * @public
     */
    MouseButtons: MouseButtons,

    /**
     * keyboard buttons
     * @property Keys
     * @public
     */
    Keys: Keys,

    /**
     * init browser instance
     * @method constructor
     * @private
     * @param  {JWebDriver} driver JWebDriver instance
     * @param  {String|Object} browserName or capabilitie object
     * @param  {String} version
     * @param  {String} platform
     * @param  {Function} done callback function
     */
    constructor(driver, browserName, version, platform){
        let self = this;
        self._driver = driver;
        self.browserName = browserName;
        self.version = version;
        self.platform = platform;
    },

    /**
     * init browser
     * @method init
     * @private
     * @param  {Function} done callback function
     */
    init(done){
        let self = this;
        let driver = self._driver;
        let browserName = self.browserName;
        let version = self.version;
        let platform = self.platform;
        let sessionInfo = {};
        if(typeof browserName === &#x27;object&#x27;){
            if(browserName.sessionId){
                self.sessionId = browserName.sessionId;
                return done();
            }
            sessionInfo = browserName;
        }
        else{
            sessionInfo.browserName = browserName;
            if(version){
                sessionInfo.version = version;
            }
            if(platform){
                sessionInfo.platform = platform;
            }
        }
        browserName = sessionInfo.browserName;
        if(browserName &amp;&amp; (browserName = mapBrowserNickName[browserName])){
            sessionInfo.browserName = browserName;
        }
        if(sessionInfo.browserName){
            sessionInfo = extend({}, defaultBrowserOptions, sessionInfo);
        }
        new Promise(function(resolve){
            let hosts = sessionInfo.hosts;
            if(hosts){
                // support hosts
                delete sessionInfo[&#x27;hosts&#x27;];
                let config = {
                    mode: &#x27;hosts&#x27;,
                    hosts: hosts
                };
                let hostsProxy = HostsProxy.createServer(config);
                hostsProxy.on(&#x27;error&#x27;, function(){});
                hostsProxy.listen(0, function(msg){
                    let localIp = getLocalIP();
                    let proxyHost = localIp+&#x27;:&#x27;+msg.port;
                    sessionInfo.proxy = {
                        &#x27;proxyType&#x27;: &#x27;manual&#x27;,
                        &#x27;httpProxy&#x27;: proxyHost,
                        &#x27;sslProxy&#x27;: proxyHost
                    };
                    self._hostsProxy = hostsProxy;
                    resolve(sessionInfo);
                });
            }
            else{
                resolve(sessionInfo);
            }
        }).then(function(sessionInfo){
            let sessionOptions = {
                &#x27;desiredCapabilities&#x27;: sessionInfo
            };
            driver.execCmd(&#x27;newSession&#x27;, {}, sessionOptions, function(error, ret){
                if(error){
                    done(error);
                }
                else{
                    self.sessionId = ret.sessionId;
                    let capabilities = ret.value;
                    self.capabilities = capabilities;
                    self.browserMode = capabilities[&#x27;browserName&#x27;] ? true : false;
                    self.mobileMode = !self.browserMode;
                    if(self.browserMode){
                        self.browserName = capabilities[&#x27;browserName&#x27;] || self.browserName;
                        self.version = capabilities[&#x27;version&#x27;] || self.version;
                        self.platform = capabilities[&#x27;platform&#x27;] || self.platform;
                    }
                    done();
                }
            }).catch(done);
        }).catch(done);
    },

    /**
     * save log
     * @method log
     * @public
     * @param  {COMMAND|DATA|RESULT|ERROR|WARNING|INFO} type log type
     * @param  {Object} message log message
     */
    log(type, message){
        this._driver.log(type, message);
    },

    /**
     * execute protocal command with this session
     * @method execCmd
     * @public
     * @param  {String} cmd protocal command, defined in command.js
     * @param  {Object} [pathData] replace the path parameters, no need to add sessionId
     * @param  {Object} [data] send data to protocal api
     * @param  {Function} done callback function
     * @return {Object} the return object from webdriver server
     */
    execCmd(cmd, pathData, data, done){
        let self = this;
        if(typeof pathData === &#x27;function&#x27;){
            pathData = undefined;
            data = undefined;
        }
        else if(typeof data === &#x27;function&#x27;){
            data = undefined;
        }
        done = getDone(arguments);
        pathData = pathData || {};
        pathData.sessionId = self.sessionId;
        self._driver.execCmd(cmd, pathData, data, done);
    },

    /**
     * get browser info
     * @method info
     * @public
     * @return {Object} info object
     */
    info(){
        return this.capabilities;
    },

    /**
     * get capability support
     * @method support
     * @public
     * @param  {String} capability
     * @return {Object} info object
     */
    support(capability){
        let capabilities = this.capabilities;
        let rawCapability = mapCapabilities[capability.toLowerCase()];
        return rawCapability &amp;&amp; capabilities[rawCapability] || false;
    },

    /**
     * sleep sync
     * @method sleep
     * @public
     * @param  {Number} ms millisecond
     * @param  {Function} done callback function
     */
    sleep(ms, done){
        this._driver.sleep(ms, done);
    },

    /**
     * config webdriver options
     * @method config
     * @public
     * @param  {String} options options for webdriver config
     * @param  {Function} done callback function
     */
    config(options, done){
        let self = this;
        // timeout
        let pageloadTimeout = options.pageloadTimeout;
        let scriptTimeout = options.scriptTimeout;
        let asyncScriptTimeout = options.asyncScriptTimeout;
        let implicitTimeout = options.implicitTimeout;
        Promise.resolve().then(function(){
            if(pageloadTimeout){
                return self.execCmd(&#x27;configTimeouts&#x27;, {}, {
                    &#x27;type&#x27;: &#x27;page load&#x27;,
                    &#x27;ms&#x27;: pageloadTimeout
                });
            }
        }).then(function(){
            if(scriptTimeout){
                return self.execCmd(&#x27;configTimeouts&#x27;, {}, {
                    &#x27;type&#x27;: &#x27;script&#x27;,
                    &#x27;ms&#x27;: scriptTimeout
                });
            }
        }).then(function(){
            if(asyncScriptTimeout){
                return self.execCmd(&#x27;configAsyncScriptTimeout&#x27;, {}, {
                    &#x27;ms&#x27;: asyncScriptTimeout
                });
            }
        }).then(function(){
            if(implicitTimeout){
                return self.execCmd(&#x27;configImplicitTimeout&#x27;, {}, {
                    &#x27;ms&#x27;: implicitTimeout
                });
            }
        }).then(function(){
            done();
        }).catch(done);
    },

    /**
     * goto url or get url
     * @method url
     * @public
     * @param  {String} [url] url for goto
     * @param  {Function} done callback function
     * @return {url|this} return this or url
     */
    url(url, done){
        let self = this;
        if(typeof url === &#x27;function&#x27;){
            url = undefined;
        }
        done = getDone(arguments);
        // goto url
        if(url){
            self.execCmd(&#x27;setUrl&#x27;, {}, {
                &#x27;url&#x27;: url
            }, done);
        }
        // get url
        else{
            self.execCmd(&#x27;getUrl&#x27;, function(error, ret){
                done(error, ret &amp;&amp; ret.value);
            });
        }
    },

    /**
     * execute script in browser
     * @method exec
     * @public
     * @param  {String|Function} script function to exec
     * @param  {Array} [args] arguments send to script
     * @param  {Function} done callback function
     * @return {any} js function returned value
     */
    exec(script, args, done){
        let self = this;
        if(typeof args === &#x27;function&#x27;){
            args = undefined;
        }
        done = getDone(arguments);
        args = args !== undefined ? args : [];
        if(args instanceof Array === false){
            args = Array.prototype.slice.call(arguments);
            script = args.shift();
            args.pop();
        }
        if(typeof script === &#x27;string&#x27; || typeof script === &#x27;function&#x27;){
            let isAsync = /(\(|,)\s*(done|callback|cb)\)/i.test(script);
            script = String(script);
            // support for: return document.title;
            if(/^\s*function\s*\(/.test(script) === false){
                script = &#x27;function(){&#x27;+script+&#x27;}&#x27;;
            }
            script = &#x27;return (&#x27; + script + &#x27;).apply(null, arguments);&#x27;;
            script = script.replace(/\n/g, &#x27;&#x27;);
            args = args.map(function(arg){
                if(arg instanceof Elements){
                    arg.toJSON(function(error, json){
                        arg = json;
                    });
                }
                return arg;
            });
            self.execCmd(isAsync?&#x27;execASync&#x27;:&#x27;exec&#x27;, {}, {
                script: script,
                args: args
            }, function(error, ret){
                done(error?&#x27;exec timeout&#x27;:null, ret &amp;&amp; ret.value);
            });
        }
        else{
            done(&#x27;First param must be string or function&#x27;);
        }
    },

    /**
     * execute script in browser
     * @method eval
     * @public
     * @param  {String|Function} script function to eval
     * @param  {Array} [args] arguments send to script
     * @param  {Function} done callback function
     * @return {any} js function returned value
     */
    eval(script, args, done){
        //jshint unused:false
        this.exec.apply(this, arguments);
    },

    /**
     * get current window handle
     * @method windowHandle
     * @public
     * @param  {Boolean} useCache
     * @param  {Function} done callback function
     * @return {String} window handle
     */
    windowHandle(useCache, done){
        let self = this;
        if(typeof useCache === &#x27;function&#x27;){
            useCache = undefined;
        }
        done = getDone(arguments);
        let windowHandle = self._windowHandle;
        if(useCache &amp;&amp; windowHandle){
            done(null, windowHandle);
        }
        else if(self.browserMode){
            self.execCmd(&#x27;getCurrentWindowHandle&#x27;, function(error, ret){
                if(ret){
                    self._windowHandle = ret.value;
                }
                done(error, ret &amp;&amp; ret.value);
            });
        }
        else{
            self._windowHandle = &#x27;current&#x27;;
            done(null, self._windowHandle);
        }
    },

    /**
     * get all window handles
     * @method windowHandles
     * @public
     * @param  {Function} done callback function
     * @return {Array} window handle
     */
    windowHandles(done){
        this.execCmd(&#x27;getAllWindowHandles&#x27;, function(error, ret){
            done(error, ret &amp;&amp; ret.value);
        });
    },

    /**
     * switch to window
     * @method switchWindow
     * @public
     * @param  {String} windowHandle window handle
     * @param  {Function} done callback function
     */
    switchWindow(windowHandle, done){
        let self = this;
        new Promise(function(resolve){
            if(typeof windowHandle === &#x27;number&#x27;){
                self.windowHandles(function(error, ret){
                    windowHandle = ret[windowHandle];
                    if(windowHandle === undefined){
                        done(&#x27;Window index overflow&#x27;);
                    }
                    else{
                        resolve(windowHandle);
                    }
                });
            }
            else{
                resolve(windowHandle);
            }
        }).then(function(windowHandle){
            self.execCmd(&#x27;switchWindow&#x27;, {}, {
                name: windowHandle
            }, function(error, ret){
                self._windowHandle = windowHandle;
                done(error, ret);
            });
        });
    },

    /**
     * open new window
     * @method newWindow
     * @public
     * @param  {String} windowHandle window handle
     * @param  {Function} done callback function
     * @return {String} return window handle
     */
    newWindow(url, name, features, done){
        let self = this;
        if(typeof name === &#x27;function&#x27;){
            name = undefined;
            features = undefined;
        }
        else if(typeof features === &#x27;function&#x27;){
            features = undefined;
        }
        done = getDone(arguments);
        let script = &#x27;function(url, name, features){window.open(url, name, features);}&#x27;;
        self.exec(script, url, name, features).then(function(){
            return self.windowHandles();
        }).then(function(arrWindowHandles){
            done(null, arrWindowHandles[arrWindowHandles.length-1]);
        }).catch(done);
    },

    /**
     * get all frame elements
     * @method frames
     * @public
     * @param  {Function} done callback function
     * @return {Element}
     */
    frames(done){
        this.find(&#x27;//iframe&#x27;, done);
    },

    /**
     * switch to frame or main page
     * @method switchFrame
     * @public
     * @param  {Elements|String} frame
     * @param  {Function} done callback function
     */
    switchFrame(frame, done){
        let self = this;
        new Promise(function(resolve){
            if(typeof frame === &#x27;string&#x27;){
                resolve(self.find(frame));
            }
            else{
                resolve(frame);
            }
        }).then(function(frame){
            if(frame instanceof Elements){
                return frame.toJSON(true);
            }
            else{
                return frame;
            }
        }).then(function(frame){
            self.execCmd(&#x27;switchFrame&#x27;, {}, {
                id : frame
            }, done);
        });
    },

    /**
     * switch to parent frame
     * @method switchFrameParent
     * @public
     * @param  {Function} done callback function
     */
    switchFrameParent(done){
        this.execCmd(&#x27;switchFrameParent&#x27;, done);
    },

    /**
     * close current window
     * @method closeWindow
     * @public
     * @param  {Function} done callback function
     */
    closeWindow(done){
        this.execCmd(&#x27;closeWindow&#x27;, done);
    },

    /**
     * get or set position of window
     * @method position
     * @public
     * @param  {Number|Object} [x] x position
     * @param  {Number|Object} [x] x position
     * @param  {Function} done callback function
     * @return {Object|this} return {x:1,y:1} or this
     */
    position(x, y, done){
        let self = this;
        if(typeof x === &#x27;function&#x27;){
            x = undefined;
            y = undefined;
        }
        else if(typeof y === &#x27;function&#x27;){
            y = undefined;
        }
        done = getDone(arguments);
        Promise.resolve(self.windowHandle(true)).then(function(windowHandle){
            if(x === undefined){
                return self.execCmd(&#x27;getWindowPosition&#x27;, {
                    windowHandle: windowHandle
                }, function(error, ret){
                    done(error, ret &amp;&amp; ret.value);
                });
            }
            else if(x.x !== undefined){
                y = x.y;
                x = x.x;
            }
            self.execCmd(&#x27;setWindowPosition&#x27;, {
                windowHandle: windowHandle
            }, {
                x: x,
                y: y
            }, done);
        }).catch(done);
    },

    /**
     * get or set size of window
     * @method size
     * @public
     * @param  {Number|Object} [width]
     * @param  {Number|Object} [height]
     * @param  {Function} done callback function
     * @return {Object|this} return {width:1,height:1} or this
     */
    size(width, height, done){
        let self = this;
        if(typeof width === &#x27;function&#x27;){
            width = undefined;
            height = undefined;
        }
        else if(typeof height === &#x27;function&#x27;){
            height = undefined;
        }
        done = getDone(arguments);
        Promise.resolve(self.windowHandle(true)).then(function(windowHandle){
            if(width === undefined){
                return self.execCmd(&#x27;getWindowSize&#x27;, {
                    windowHandle: windowHandle
                }, function(error, ret){
                    done(error, ret &amp;&amp; ret.value);
                });
            }
            else if(width.width !== undefined){
                height = width.height;
                width = width.width;
            }
            self.execCmd(&#x27;setWindowSize&#x27;, {
                windowHandle: windowHandle
            }, {
                width: width,
                height: height
            }, done);
        }).catch(done);
    },

    /**
     * maximize the window
     * @method maximize
     * @public
     * @param  {Function} done callback function
     */
    maximize(done){
        let self = this;
        Promise.resolve(self.windowHandle(true)).then(function(windowHandle){
            self.execCmd(&#x27;maximizeWindow&#x27;, {
                windowHandle : windowHandle
            }, done);
        }).catch(done);

    },

    /**
     * get screenshot
     * @method getScreenshot
     * @public
     * @param  {String} [filename] save screenshot to file
     * @param  {Function} done callback function
     * @return {String} return screenshot by base64 format
     */
    getScreenshot(filename, done){
        if(typeof filename === &#x27;function&#x27;){
            filename = undefined;
        }
        done = getDone(arguments);
        this.execCmd(&#x27;getScreenshot&#x27;, function(error, ret){
            var png64 = ret &amp;&amp; ret.value;
            if(png64 &amp;&amp; filename){
                fs.writeFileSync(filename, png64, &#x27;base64&#x27;);
            }
            done(error, ret &amp;&amp; ret.value);
        });
    },

    /**
     * get title
     * @method title
     * @public
     * @param  {Function} done callback function
     * @return {String} return document title
     */
    title(done){
        this.execCmd(&#x27;getTitle&#x27;, function(error, ret){
            done(error, ret &amp;&amp; ret.value);
        });
    },

    /**
     * get source
     * @method source
     * @public
     * @param  {Function} done callback function
     * @return {String} return source
     */
    source(done){
        this.execCmd(&#x27;getSource&#x27;, function(error, ret){
            done(error, ret &amp;&amp; ret.value);
        });
    },

    /**
     * nick name of source
     * @method html
     * @public
     * @param  {Function} done callback function
     * @return {String} return document html
     */
    html(done){
        this.execCmd(&#x27;getSource&#x27;, function(error, ret){
            done(error, ret &amp;&amp; ret.value);
        });
    },

    /**
     * refresh the window
     * @method refresh
     * @public
     * @param  {Function} done callback function
     */
    refresh(done){
        this.execCmd(&#x27;setRefresh&#x27;, done);
    },

    /**
     * back the window
     * @method back
     * @public
     * @param  {Function} done callback function
     */
    back(done){
        this.execCmd(&#x27;setBack&#x27;, done);
    },

    /**
     * forward the window
     * @method forward
     * @public
     * @param  {Function} done callback function
     */
    forward(done){
        this.execCmd(&#x27;setForward&#x27;, done);
    },

    /**
     * get all cookies
     * @method cookies
     * @public
     * @param  {Boolean} isArray
     * @param  {Function} done callback function
     * @return {Array} return all cookies
     */
    cookies(isArray, done){
        if(typeof isArray === &#x27;function&#x27;){
            isArray = undefined;
        }
        done = getDone(arguments);
        this.execCmd(&#x27;getAllCookies&#x27;, function(error, ret){
            if(error){
                done(error);
            }
            else{
                let arrCookies = ret.value;
                if(isArray){
                    done(null, arrCookies);
                }
                else{
                    let mapCookies = {};
                    arrCookies.forEach(function(cookie){
                        mapCookies[cookie.name] = cookie;
                    });
                    done(null, mapCookies);
                }
            }
        });

    },

    /**
     * get or set cookie
     * @method cookie
     * @public
     * @param  {String} name cookie name
     * @param  {String} [value] cookie value
     * @param  {Object} [options] options for cookie
     * @param  {Function} done callback function
     * @return {String} return cookie value or this
     */
    cookie(name, value, options, done){
        let self = this;
        if(typeof value === &#x27;function&#x27;){
            value = undefined;
            options = undefined;
        }
        else if(typeof options === &#x27;function&#x27;){
            options = undefined;
        }
        done = getDone(arguments);
        let cookieInfo;
        if(value === undefined){
            self.cookies(function(error, ret){
                if(error){
                    done(error);
                }
                else{
                    cookieInfo = ret[name];
                    done(null, cookieInfo &amp;&amp; cookieInfo.value);
                }
            });
        }
        else{
            cookieInfo = options || {};
            cookieInfo.name = String(name);
            cookieInfo.value = String(value);
            let expiry = cookieInfo.expiry;
            if(expiry &amp;&amp; typeof expiry === &#x27;string&#x27;){
                let match = expiry.match(/^(\d+)\s*(second|minute|hour|day|month|year)s?$/);
                if(match !== null){
                    let number = parseInt(match[1], 10);
                    let unit = match[2];
                    let date = new Date();
                    switch(unit){
                        case &#x27;second&#x27;:
                            date.setSeconds(date.getSeconds() + number);
                            break;
                        case &#x27;minute&#x27;:
                            date.setMinutes(date.getMinutes() + number);
                            break;
                        case &#x27;hour&#x27;:
                            date.setHours(date.getHours() + number);
                            break;
                        case &#x27;day&#x27;:
                            date.setDate(date.getDate() + number);
                            break;
                        case &#x27;month&#x27;:
                            date.setMonth(date.getMonth() + number);
                            break;
                        case &#x27;year&#x27;:
                            date.setFullYear(date.getFullYear() + number);
                            break;
                    }
                    cookieInfo.expiry = date.getTime() / 1000;
                }
                else{
                    done(&#x27;Bad format for expiry: &#x27; + expiry);
                }
            }
            self.execCmd(&#x27;setCookie&#x27;, {}, {
                cookie: cookieInfo
            }, done);
        }
    },

    /**
     * remove cookie
     * @method removeCookie
     * @public
     * @param  {String} name cookie name
     * @param  {Function} done callback function
     */
    removeCookie(name, done){
        this.execCmd(&#x27;delCookie&#x27;, {
            name: name
        }, done);
    },

    /**
     * clear all cookies
     * @method clearCookies
     * @public
     * @param  {Function} done callback function
     */
    clearCookies(done){
        this.execCmd(&#x27;clearAllCookies&#x27;, done);
    },

    /**
     * get all local storage keys
     * @method localStorageKeys
     * @public
     * @param  {Function} done callback function
     * @return {Array} return all local storage keys
     */
    localStorageKeys(done){
        this.execCmd(&#x27;getAllLocalStorageKeys&#x27;, function(error, ret){
            done(error, ret &amp;&amp; ret.value);
        });
    },

    /**
     * get or set local storage
     * @method localStorage
     * @public
     * @param  {String} name local storage name
     * @param  {String} [value] local storage value
     * @param  {Function} done callback function
     * @return {String} return local storage value or this
     */
    localStorage(name, value, done){
        let self = this;
        if(typeof value === &#x27;function&#x27;){
            value = undefined;
        }
        done = getDone(arguments);
        if(value !== undefined){
            self.execCmd(&#x27;setLocalStorage&#x27;, {}, {
                key: String(name),
                value: String(value)
            }, done);
        }
        else{
            self.execCmd(&#x27;getLocalStorage&#x27;, {
                key: String(name)
            }, function(error, ret){
                done(error, ret &amp;&amp; ret.value);
            });
        }
    },

    /**
     * remove local storage
     * @method removeLocalStorage
     * @public
     * @param  {String} name local storage name
     * @param  {Function} done callback function
     */
    removeLocalStorage(name, done){
        this.execCmd(&#x27;deleteLocalStorage&#x27;, {
            key: name
        }, done);
    },

    /**
     * clear all local storage
     * @method clearLocalStorages
     * @public
     * @param  {Function} done callback function
     */
    clearLocalStorages(done){
        this.execCmd(&#x27;clearAllLocalStorages&#x27;, done);
    },

    /**
     * get all session storage keys
     * @method sessionStorageKeys
     * @public
     * @param  {Function} done callback function
     * @return {Array} return all session storage keys
     */
    sessionStorageKeys(done){
        this.execCmd(&#x27;getAllSessionStorageKeys&#x27;, function(error, ret){
            done(error, ret &amp;&amp; ret.value);
        });
    },

    /**
     * get or set session storage
     * @method sessionStorage
     * @public
     * @param  {String} name session storage name
     * @param  {String} [value] session storage value
     * @param  {Function} done callback function
     * @return {String} return session storage value or this
     */
    sessionStorage(name, value, done){
        let self = this;
        if(typeof value === &#x27;function&#x27;){
            value = undefined;
        }
        done = getDone(arguments);
        if(value !== undefined){
            self.execCmd(&#x27;setSessionStorage&#x27;, {}, {
                key: String(name),
                value: String(value)
            }, done);
        }
        else{
            self.execCmd(&#x27;getSessionStorage&#x27;, {
                key: String(name)
            }, function(error, ret){
                done(error, ret &amp;&amp; ret.value);
            });
        }
    },

    /**
     * remove session storage
     * @method removeSessionStorage
     * @public
     * @param  {String} name session storage name
     * @param  {Function} done callback function
     */
    removeSessionStorage(name, done){
        this.execCmd(&#x27;deleteSessionStorage&#x27;, {
            key: name
        }, done);
    },

    /**
     * clear all session storage
     * @method clearSessionStorages
     * @public
     * @param  {Function} done callback function
     */
    clearSessionStorages(done){
        this.execCmd(&#x27;clearAllSessionStorages&#x27;, done);
    },

    /**
     * get alert text
     * @method getAlert
     * @public
     * @param  {Function} done callback function
     * @return {String}
     */
    getAlert(done){
        this.execCmd(&#x27;getAlert&#x27;, function(error, ret){
            done(error, ret &amp;&amp; ret.value);
        });
    },

    /**
     * accept alert or confirm
     * @method acceptAlert
     * @public
     * @param  {Function} done callback function
     */
    acceptAlert(done){
        this.execCmd(&#x27;acceptAlert&#x27;, done);
    },

    /**
     * dismiss confirm
     * @method dismissAlert
     * @public
     * @param  {Function} done callback function
     */
    dismissAlert(done){
        this.execCmd(&#x27;dismissAlert&#x27;, done);
    },

    /**
     * set text to prompt
     * @method setAlert
     * @public
     * @param  {String} text
     * @param  {Function} done callback function
     */
    setAlert(text, done){
        this.execCmd(&#x27;setAlert&#x27;, {}, {
            text: text
        }, done);
    },

    /**
     * send keys to browser
     * @method sendKeys
     * @public
     * @param  {String} text
     * @param  {Function} done callback function
     */
    sendKeys(text, done){
        let self = this;
        let Keys = self.Keys;
        text = text.replace(/{(\w+)}/g, function(all, name){
            let key = Keys[name.toUpperCase()];
            return key?key:all;
        });
        self.execCmd(&#x27;sendKeys&#x27;, {}, {
            value: text.split(&#x27;&#x27;)
        }, done);
    },

    /**
     * check sticky key
     * @method isStickyKey
     * @public
     * @param  {String} key
     * @return {Boolean}
     */
    isStickyKey(key){
        let Keys = this.Keys;
        return key === Keys.CTRL || key === Keys.SHIFT || key === Keys.ALT || key === Keys.META;
    },

    /**
     * send keydown
     * @method keyDown
     * @public
     * @param  {String} key
     * @param  {Function} done callback function
     */
    keyDown(key, done){
        let self = this;
        let Keys = self.Keys;
        key = Keys[key.toUpperCase()] || key;
        if(self.isStickyKey(key)){
            self.sendKeys(key, done);
        }
        else{
            done(&#x27;keyDown or keyUp only support: CTRL|SHIFT|ALT|COMMAND|META&#x27;);
        }
    },

    /**
     * send keyup
     * @method keyUp
     * @public
     * @param  {String} key
     * @param  {Function} done callback function
     */
    keyUp(key, done){
        let self = this;
        let Keys = self.Keys;
        key = Keys[key.toUpperCase()] || key;
        if(self.isStickyKey(key)){
            self.sendKeys(key, done);
        }
        else{
            done(&#x27;keyDown or keyUp only support: CTRL|SHIFT|ALT|COMMAND|META&#x27;);
        }
    },

    /**
     * send mousemove (first element)
     * @method mouseMove
     * @public
     * @param  {Elements|String} elements
     * @param  {Number|Object} [x]
     * @param  {Number} [y]
     * @param  {Function} done callback function
     */
    mouseMove(elements, x, y, done){
        let self = this;
        if(typeof x === &#x27;function&#x27;){
            x = undefined;
            y = undefined;
        }
        else if(typeof y === &#x27;function&#x27;){
            y = undefined;
        }
        done = getDone(arguments);
        new Promise(function(resolve){
            if(typeof elements === &#x27;string&#x27;){
                resolve(self.find(elements));
            }
            else{
                resolve(elements);
            }
        }).then(function(elements){
            let data = {};
            if(elements.length &gt; 0){
                data.element = elements.elementIds[0];
            }
            else{
                return done(&#x27;Elements empty: &#x27;+ elements.value+&#x27; (&#x27;+elements.using+&#x27;)&#x27;);
            }
            if(x !== undefined &amp;&amp; x.x !== undefined){
                y = x.y;
                x = x.x;
            }
            if(x !== undefined &amp;&amp; y !== undefined){
                data.xoffset = x;
                data.yoffset = y;
            }
            self.execCmd(&#x27;mouseMove&#x27;, {}, data, done);
        }).catch(done);
    },

    /**
     * send mousedown
     * @method mouseDown
     * @public
     * @param  {String} [key]
     * @param  {Function} done callback function
     */
    mouseDown(key, done){
        let self = this;
        if(typeof key === &#x27;function&#x27;){
            key = undefined;
        }
        done = getDone(arguments);
        if(typeof key === &#x27;string&#x27;){
            let MouseButtons = self.MouseButtons;
            key = key.toUpperCase();
            key = MouseButtons[key] || 0;
        }
        self.execCmd(&#x27;mouseDown&#x27;, {}, {
            button: key || 0
        }, done);
    },

    /**
     * send mouseup
     * @method mouseUp
     * @public
     * @param  {String} [key]
     * @param  {Function} done callback function
     */
    mouseUp(key, done){
        let self = this;
        if(typeof key === &#x27;function&#x27;){
            key = undefined;
        }
        done = getDone(arguments);
        if(typeof key === &#x27;string&#x27;){
            let MouseButtons = self.MouseButtons;
            key = key.toUpperCase();
            key = MouseButtons[key] || 0;
        }
        self.execCmd(&#x27;mouseUp&#x27;, {}, {
            button: key || 0
        }, done);
    },

    /**
     * send click
     * @method click
     * @public
     * @param  {String} [key]
     * @param  {Function} done callback function
     */
    click(key, done){
        let self = this;
        if(typeof key === &#x27;function&#x27;){
            key = undefined;
        }
        done = getDone(arguments);
        if(typeof key === &#x27;string&#x27;){
            let MouseButtons = self.MouseButtons;
            key = key.toUpperCase();
            key = MouseButtons[key] || 0;
        }
        self.execCmd(&#x27;click&#x27;, {}, {
            button: key || 0
        }, done);
    },

    /**
     * send double Click
     * @method dblClick
     * @public
     * @param  {Function} done callback function
     */
    dblClick(done){
        this.execCmd(&#x27;doubleClick&#x27;, done);
    },

    /**
     * send double Click
     * @method doubleClick
     * @public
     * @param  {Function} done callback function
     */
    doubleClick(done){
        this.execCmd(&#x27;doubleClick&#x27;, done);
    },

    /**
     * drag one element to another
     * @method dragDrop
     * @public
     * @param  {Elements} from
     * @param  {Elements} to
     * @param  {Function} done callback function
     */
    dragDrop(from, to, done){
        let self = this;
        let fromOffset;
        if(from.selector){
            fromOffset = {
                x: from.x,
                y: from.y
            };
            from = from.selector;
        }
        let toOffset;
        if(to.selector){
            toOffset = {
                x: to.x,
                y: to.y
            };
            to = to.selector;
        }
        self.mouseMove(from, fromOffset).mouseDown().mouseMove(to, toOffset).mouseUp().then(function(){
            done();
        }).catch(done);
    },

    /**
     * find element
     * @method find
     * @public
     * @param  {String} [using] find mode: class name|css selector|id|name|link text|partial link text|tag name|xpath
     * @param  {String} value find pattern
     * @param  {Function} done callback function
     * @return {Elments}
     */
    find(using, value, done){
        if(typeof value === &#x27;function&#x27;){
            value = undefined;
        }
        done = getDone(arguments);
        let elements = new Elements(this, using, value);
        elements.init(function(error){
            done(error, elements);
        }).catch(done);
    },

    /**
     * find visible element
     * @method findVisible
     * @public
     * @param  {String} [using] find mode: class name|css selector|id|name|link text|partial link text|tag name|xpath
     * @param  {String} value find pattern
     * @param  {Function} done callback function
     * @return {Elments}
     */
    findVisible(using, value, done){
        let self = this;
        if(typeof value === &#x27;function&#x27;){
            value = undefined;
        }
        done = getDone(arguments);
        self.find(using, value, function*(error, elements){
            if(elements.length &gt; 0){
                let json = yield elements.toJSON();
                // filter visible element
                let newJson = [];
                try{
                    newJson = yield self.exec(&#x27;function(arg1){\
                        function curCSS(elem, name){\
                            var curStyle = elem.currentStyle;\
                            var style = elem.style;\
                            return (curStyle &amp;&amp; curStyle[name]) || (style &amp;&amp; style[name]);\
                        }\
                        function isHidden(elem){\
                            return ( elem.offsetWidth === 0 &amp;&amp; elem.offsetHeight === 0 ) || (curCSS( elem, &quot;display&quot; ) === &quot;none&quot;);\
                        }\
                        var elements = arg1.elements;\
                        var newElements = [], element;\
                        for(var i in elements){\
                            element = elements[i];\
                            if(!isHidden(element)){\
                                newElements.push(element);\
                            }\
                        }\
                        return newElements;\
                    }&#x27;, {elements: json});
                }
                catch(e){}
                if(newJson.length === 0){
                    let message = &#x27;Find visible elements failed&#x27;;
                    self.log(&#x27;ERROR&#x27;, message);
                    done(message);
                }
                else{
                    let elementIds = [];
                    newJson.forEach(function(element){
                        elementIds.push(element.ELEMENT);
                    });
                    elements.elementIds = elementIds;
                    elements.length = elementIds.length;
                    done(null, elements);
                }
            }
            else{
                done(error);
            }
        }).catch(done);
    },

    /**
     * wait for element displayed or removed
     * @method wait
     * @public
     * @param  {String} [using] find mode: class name|css selector|id|name|link text|partial link text|tag name|xpath
     * @param  {String} value find pattern
     * @param  {String} [options]
     * @param  {Function} done callback function
     * @return {Elments}
     */
    wait(using, value, options, done){
        let self = this;
        if(typeof options === &#x27;function&#x27;){
            if(typeof value === &#x27;string&#x27;){
                // using, value, done
                options = undefined;
            }
            else{
                // value, options, done
                options = value;
                value = using;
                using = undefined;
            }
        }
        else if(typeof value === &#x27;function&#x27;){
            // value, done
            value = using;
            using = undefined;
            options = undefined;
        }
        done = getDone(arguments);
        if(typeof options === &#x27;number&#x27;){
            options = {
                timeout: options
            };
        }
        options = extend({}, {
            timeout: 10000,
            displayed: true,
            removed: false
        }, options);
        let timeout = options.timeout;
        let removed = options.removed;
        let displayed = removed ? false : options.displayed;
        let startTime = new Date().getTime();
        let _timer = null;
        waitElement();
        function endWait(error, result){
            clearInterval(_timer);
            done(error, result);
        }
        function waitElement(){
            self[(!self.mobileMode &amp;&amp; displayed)?&#x27;findVisible&#x27;:&#x27;find&#x27;](using, value, function(error, elements){
                if(elements){
                    if(removed === true &amp;&amp; elements.length === 0){
                        // removed
                        return endWait(null, elements);
                    }
                    else if(removed === false &amp;&amp; elements.length &gt; 0){
                        if(displayed){
                            // displayed
                            return endWait(null, elements);
                        }
                        else{
                            // wait dom
                            return endWait(null, elements);
                        }
                    }
                }
                // timeout
                if(new Date().getTime() - startTime &gt; timeout){
                    let message = &#x27;Wait elelment &#x27;+(removed?&#x27;removed&#x27;:&#x27;displayed&#x27;)+&#x27; timeout: &#x27;+(using?(using+&#x27; ,&#x27;):&#x27;&#x27;)+value+&#x27; ,&#x27; + timeout + &#x27;ms&#x27;;
                    self.log(&#x27;ERROR&#x27;, message);
                    endWait(message);
                }
                else{
                    _timer = setTimeout(waitElement, 500);
                }
            });
        }
    },

    /**
     * scroll to
     * @method scrollTo
     * @public
     * @param  {Elements|String} [elements]
     * @param  {Number} [x]
     * @param  {Number} [y]
     * @param  {Function} done callback function
     */
    scrollTo(elements, x, y, done){
        let self = this;
        if(typeof x === &#x27;function&#x27;){
            x = undefined;
            y = undefined;
        }
        else if(typeof y === &#x27;function&#x27;){
            y = undefined;
        }
        done = getDone(arguments);
        new Promise(function(resolve){
            if(typeof elements === &#x27;string&#x27;){
                resolve(self.find(elements));
            }
            else{
                resolve(elements);
            }
        }).then(function(elements){
            if(elements instanceof Elements){
                return new Promise(function(resolve){
                    elements.offset(function(error, offset){
                        if(x !== undefined &amp;&amp; x.x !== undefined){
                            y = x.y;
                            x = x.x;
                        }
                        offset.x += x || 0;
                        offset.y += y || 0;
                        x = offset.x;
                        y = offset.y;
                        resolve({
                            x: x,
                            y: y
                        });
                    });
                });
            }
            else{
                // no elements
                y = x;
                x = elements;
                if(x !== undefined &amp;&amp; x.x !== undefined){
                    y = x.y;
                    x = x.x;
                }
                return {
                    x: x,
                    y: y
                };
            }

        }).then(function(offset){
            let script = &#x27;function(x, y){window.scrollTo(x, y);}&#x27;;
            self.exec(script, offset.x, offset.y, done);
        }).catch(done);
    },

    /**
     * upload file to browser machine
     * @method uploadFileToServer
     * @public
     * @param  {String} localPath
     * @param  {Function} done callback function
     * @return {String} webdriver server filepath
     */
    uploadFileToServer(localPath, done){
        let self = this;
        if(fs.existsSync(localPath)){
            let filedata = fs.readFileSync(localPath);
            let zip = new Zip();
            zip.file(path.basename(localPath), filedata);
            let base64zip = zip.generate({base64:true, compression:&#x27;DEFLATE&#x27;});
            self.execCmd(&#x27;uploadFile&#x27;, {}, {
                file: base64zip
            }, function(error, ret){
                done(error, ret &amp;&amp; ret.value);
            });
        }
        else{
            done(&#x27;localPath no existed&#x27;);
        }
    },

    /**
     * touch down
     * @method touchDown
     * @public
     * @param  {Number} x
     * @param  {Number} y
     * @param  {Function} done callback function
     */
    touchDown(x, y, done){
        let self = this;
        if(typeof x === &#x27;function&#x27;){
            x = undefined;
            y = undefined;
        }
        else if(typeof y === &#x27;function&#x27;){
            y = undefined;
        }
        done = getDone(arguments);
        if(x !== undefined &amp;&amp; x.x !== undefined){
            y = x.y;
            x = x.x;
        }
        self.execCmd(&#x27;touchDown&#x27;, {}, {
            x: x,
            y: y
        }, done);
    },

    /**
     * touch move
     * @method touchMove
     * @public
     * @param  {Number} x
     * @param  {Number} y
     * @param  {Function} done callback function
     */
    touchMove(x, y, done){
        let self = this;
        if(typeof x === &#x27;function&#x27;){
            x = undefined;
            y = undefined;
        }
        else if(typeof y === &#x27;function&#x27;){
            y = undefined;
        }
        done = getDone(arguments);
        if(x !== undefined &amp;&amp; x.x !== undefined){
            y = x.y;
            x = x.x;
        }
        self.execCmd(&#x27;touchMove&#x27;, {}, {
            x: x,
            y: y
        }, done);
    },

    /**
     * touch up
     * @method touchUp
     * @public
     * @param  {Number} x
     * @param  {Number} y
     * @param  {Function} done callback function
     */
    touchUp(x, y, done){
        let self = this;
        if(typeof x === &#x27;function&#x27;){
            x = undefined;
            y = undefined;
        }
        else if(typeof y === &#x27;function&#x27;){
            y = undefined;
        }
        done = getDone(arguments);
        if(x !== undefined &amp;&amp; x.x !== undefined){
            y = x.y;
            x = x.x;
        }
        self.execCmd(&#x27;touchUp&#x27;, {}, {
            x: x,
            y: y
        }, done);
    },

    /**
     * touch scroll
     * @method touchScroll
     * @public
     * @param  {Number} x
     * @param  {Number} y
     * @param  {Function} done callback function
     */
    touchScroll(x, y, done){
        let self = this;
        if(typeof x === &#x27;function&#x27;){
            x = undefined;
            y = undefined;
        }
        else if(typeof y === &#x27;function&#x27;){
            y = undefined;
        }
        done = getDone(arguments);
        if(x !== undefined &amp;&amp; x.x !== undefined){
            y = x.y;
            x = x.x;
        }
        self.execCmd(&#x27;touchScroll&#x27;, {}, {
            xoffset: x,
            yoffset: y,
        }, done);
    },

    /**
     * touch flick
     * @method touchFlick
     * @public
     * @param  {Number} xspeed
     * @param  {Number} yspeed
     * @param  {Function} done callback function
     */
    touchFlick(xspeed , yspeed, done){
        let self = this;
        if(typeof xspeed === &#x27;function&#x27;){
            xspeed = undefined;
            yspeed = undefined;
        }
        else if(typeof yspeed === &#x27;function&#x27;){
            yspeed = undefined;
        }
        done = getDone(arguments);
        if(xspeed !== undefined &amp;&amp; xspeed.xspeed !== undefined){
            yspeed = xspeed.yspeed;
            xspeed = xspeed.xspeed;
        }
        self.execCmd(&#x27;touchFlick&#x27;, {}, {
            xspeed: xspeed,
            yspeed: yspeed,
        }, done);
    },

    /**
     * get or set orientation
     * @method orientation
     * @public
     * @param  {String} [orientation] orientation
     * @param  {Function} done callback function
     * @return {Object|this} return {x:1,y:1} or this
     */
    orientation(orientation, done){
        let self = this;
        if(typeof orientation === &#x27;function&#x27;){
            orientation = undefined;
        }
        done = getDone(arguments);
        if(orientation){
            self.execCmd(&#x27;setOrientation&#x27;, {}, {
                orientation: orientation
            }, function(error, ret){
                done(error, ret &amp;&amp; ret.value);
            });
        }
        else{
            self.execCmd(&#x27;getOrientation&#x27;, function(error, ret){
                done(error, ret &amp;&amp; ret.value);
            });
        }
    },

    /**
     * get or set geolocation
     * @method geolocation
     * @public
     * @param  {Number|Object} [latitude] latitude
     * @param  {Number} [longitude] longitude
     * @param  {Number} [altitude] altitude
     * @param  {Function} done callback function
     * @return {Object} return {latitude:1, longitude:1, altitude:1}
     */
    geolocation(latitude, longitude, altitude, done){
        let self = this;
        if(typeof latitude === &#x27;function&#x27;){
            latitude = undefined;
        }
        done = getDone(arguments);
        if(latitude !== undefined &amp;&amp; latitude.latitude !== undefined){
            longitude = latitude.longitude;
            altitude = latitude.altitude;
            latitude = latitude.latitude;
        }
        if(latitude !== undefined){
            self.execCmd(&#x27;setLocation&#x27;, {}, {
                location: {
                    latitude: latitude,
                    longitude: longitude,
                    altitude: altitude
                }
            }, function(error, ret){
                done(error, ret &amp;&amp; ret.value);
            });
        }
        else{
            self.execCmd(&#x27;getLocation&#x27;, function(error, ret){
                done(error, ret &amp;&amp; ret.value);
            });
        }
    },

    /**
     * close session
     * @method close
     * @public
     * @param  {Function} done callback function
     */
    close(done){
        let self = this;
        self.execCmd(&#x27;delSession&#x27;, function(error){
            let hostsProxy = self._hostsProxy;
            if(hostsProxy){
                hostsProxy.close(function(){
                    done(error);
                });
            }
            else{
                done(error);
            }
        });
    },

    /**
     * get contexts
     * @method contexts
     * @param  {Function} done callback function
     */
    contexts(done){
        this.execCmd(&#x27;getContexts&#x27;, function(error, ret){
            done(error, ret &amp;&amp; ret.value);
        });
    },

    /**
     * get or set context
     * @method context
     * @public
     * @param  {String} [contextId] context id
     * @param  {Function} done callback function
     */
    context(contextId, done){
        let self = this;
        if(typeof contextId === &#x27;function&#x27;){
            contextId = undefined;
        }
        done = getDone(arguments);
        if(contextId){
            self.browserMode = contextId !== &#x27;NATIVE_APP&#x27;;
        }
        self.execCmd(contextId ? &#x27;setContext&#x27; : &#x27;getContext&#x27;, {}, {
            name: contextId
        }, function(error, ret){
            done(error, ret &amp;&amp; ret.value);
        });
    },

    /**
     * set context to native
     * @method native
     * @param  {Function} done callback function
     */
    native(){
        return this.contexts(function(error, arrContexts){
            return this.context(arrContexts[0]);
        });
    },

    /**
     * set context to webview
     * @method webview
     * @param  {Function} done callback function
     */
    webview(){
        return this.contexts(function(error, arrContexts){
            return this.context(arrContexts[arrContexts.length - 1]);
        });
    },

    /**
     * send actions
     * @method sendActions
     * @public
     * @param  {String} type
     * @param  {Object} params
     * @param  {Function} done callback function
     */
    sendActions(type, params, done){
        let actions = [];
        if(done === undefined){
            actions = Array.isArray(type) ? type : [{
                type: type
            }];
        }
        else{
            params.type = type;
            actions.push(params);
        }
        done = getDone(arguments);
        this.execCmd(&#x27;setActions&#x27;, {}, {
            actions: actions
        }, done);
    }

});


// get done callback
function getDone(args){
    let done = args[args.length -1];
    return typeof done === &#x27;function&#x27; ? done : null;
}

// get local ip
function getLocalIP() {
    let ifaces = os.networkInterfaces();
    for (let dev in ifaces) {
        if(/(VirtualBox|Loopback)/i.test(dev) === false){
            let iface = ifaces[dev];
            for (let i = 0; i &lt; iface.length; i++) {
                let alias = iface[i];
                if (alias.family === &#x27;IPv4&#x27; &amp;&amp; alias.address !== &#x27;127.0.0.1&#x27; &amp;&amp; !alias.internal){
                    return alias.address;
                }
            }
        }
    }
}

module.exports = Browser;

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
